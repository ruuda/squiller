// Squiller -- Generate boilerplate from SQL for statically typed languages
// Copyright 2022 Ruud van Asseldonk

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// A copy of the License has been included in the root of the repository.

use crate::ast::ArgType;
use crate::codegen::python::PythonCodeGenerator;
use crate::NamedDocument;

use std::io;

const PREAMBLE: &str = r#"
from __future__ import annotations

import contextlib

from typing import Iterator, NamedTuple, Optional

import psycopg2.extensions  # type: ignore
import psycopg2.extras  # type: ignore
import psycopg2.pool  # type: ignore


class Transaction:
    def __init__(self, conn: psycopg2.extensions.connection) -> None:
        self.conn = conn

    def commit(self) -> None:
        self.conn.commit()
        # Ensure we cannot reuse the connection.
        self.conn = None

    def rollback(self) -> None:
        self.conn.rollback()
        self.conn = None

    def cursor(self) -> psycopg2.extensions.cursor:
        return self.conn.cursor()


class ConnectionPool(NamedTuple):
    pool: psycopg2.pool.ThreadedConnectionPool

    @contextlib.contextmanager
    def begin(self) -> Iterator[Transaction]:
        conn: Optional[psycopg2.extensions.connection] = None
        try:
            # Use psycopg2 in "no-autocommit" mode, where it implicitly starts a
            # transaction at the first statement, and we need to explicitly
            # commit() or rollback() afterwards.
            conn = self.pool.getconn()
            conn.isolation_level = "SERIALIZABLE"
            conn.autocommit = False
            yield Transaction(conn)

        except:
            if conn is not None:
                self.pool.putconn(conn, close=True)
            raise

        else:
            assert conn is not None
            self.pool.putconn(conn, close=False)
"#;

/// Generate Python code that uses the `psycopg2` package.
pub fn process_documents(out: &mut dyn io::Write, documents: &[NamedDocument]) -> io::Result<()> {
    use crate::version::{REV, VERSION};

    let mut gen = PythonCodeGenerator::new(out);

    write!(gen, "# This file was generated by Squiller {} ", VERSION)?;
    match REV {
        Some(rev) => writeln!(gen, " (commit {}).", &rev[..10])?,
        None => writeln!(gen, " (unspecified checkout).")?,
    }
    writeln!(gen, "# Input files:")?;
    for doc in documents {
        writeln!(gen, "# - {}", doc.fname.to_string_lossy())?;
    }

    gen.write(PREAMBLE)?;

    for named_document in documents {
        let input = named_document.input;

        for query in named_document.document.iter_queries() {
            let ann = &query.annotation;

            write!(gen, "\n\ndef {}(tx: Transaction", ann.name.resolve(input))?;

            match &ann.arguments {
                ArgType::Args(args) => {
                    for arg in args {
                        // TODO: Include types.
                        gen.write(", ")?;
                        gen.write(arg.ident.resolve(input))?;
                    }
                }
                ArgType::Struct {
                    var_name,
                    type_name,
                    ..
                } => {
                    write!(
                        gen,
                        ", {}: {}",
                        var_name.resolve(input),
                        type_name.resolve(input)
                    )?;
                }
            }
            gen.write("):\n")?;
            gen.open_scope();
            gen.write_indent()?;
            gen.write("pass\n")?;
            gen.close_scope();
        }
    }

    Ok(())
}
