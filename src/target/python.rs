// Squiller -- Generate boilerplate from SQL for statically typed languages
// Copyright 2023 Ruud van Asseldonk

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// A copy of the License has been included in the root of the repository.

/// Shared code generation for all Python targets.

use crate::{Span, NamedDocument};
use crate::ast::{Annotation, ArgType, ResultType};
use crate::codegen::Result;
use crate::codegen::python::PythonCodeGenerator;

pub fn write_header_comment(gen: &mut PythonCodeGenerator, documents: &[NamedDocument]) -> Result {
    use crate::version::{REV, VERSION};

    write!(gen, "# This file was generated by Squiller {} ", VERSION)?;
    match REV {
        Some(rev) => writeln!(gen, " (commit {}).", &rev[..10])?,
        None => writeln!(gen, " (unspecified checkout).")?,
    }
    writeln!(gen, "# Input files:")?;
    for doc in documents {
        writeln!(gen, "# - {}", doc.fname.to_string_lossy())?;
    }

    Ok(())
}

pub fn write_function_signature(
    gen: &mut PythonCodeGenerator,
    ann: &Annotation<Span>,
    input: &str,
) -> Result {
    write!(gen, "\n\ndef {}(tx: Transaction", ann.name.resolve(input))?;

    match &ann.arguments {
        ArgType::Args(args) => {
            for arg in args {
                // TODO: Include types.
                gen.write(", ")?;
                gen.write(arg.ident.resolve(input))?;
            }
        }
        ArgType::Struct {
            var_name,
            type_name,
            ..
        } => {
            write!(
                gen,
                ", {}: {}",
                var_name.resolve(input),
                type_name.resolve(input)
            )?;
        }
    }

    gen.write(") -> ")?;
    match &ann.result_type {
        ResultType::Unit => gen.write("None:\n")?,
        ResultType::Option(_t) => {
            // TODO: Write the actual type.
            // TODO: Ensure import.
            gen.write("Optional[Any]:\n")?;
        }
        ResultType::Single(_t) => {
            // TODO: Write the actual type.
            gen.write("Any:\n")?;
        }
        ResultType::Iterator(_t) => {
            // TODO: Write the actual type.
            // TODO: Ensure import.
            gen.write("Iterator[Any]:\n")?;
        }
    }

    Ok(())
}

/// Write the docstring, if there are doc comments.
pub fn write_docstring(
    gen: &mut PythonCodeGenerator,
    docs: &[Span],
    input: &str,
) -> Result {
    if !docs.is_empty() {
        gen.write_indent()?;
        gen.write("\"\"\"\n")?;
        for doc_line in docs {
            gen.write_indent()?;
            // The comment lines usually start with a space that went after
            // the "--" that starts the comment. In Python docstrings, we
            // don't want to start the line with a space, so remove them.
            let doc_line_str = doc_line.resolve(input);
            let line_content = match doc_line_str.as_bytes().first() {
                Some(b' ') => &doc_line_str[1..],
                _ => doc_line_str,
            };
            gen.write(line_content)?;
            gen.write("\n")?;
        }
        gen.write_indent()?;
        gen.write("\"\"\"\n")?;
    }
    Ok(())
}
