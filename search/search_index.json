{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Squiller \u00b6 Squiller generates boilerplate code from annotated SQL queries. Working with SQL is often tedious, especially in statically typed settings. You need to explicitly bind values to parameters, and extract the resulting values for every column with the right type. Squiller can generate this boilerplate code from a SQL file, based on annotations in comments. Vaporware warning: This is a work in progress. Basic code generation for rust-sqlite works, but the project is pre-alpha quality. Example \u00b6 Given the following input: -- Look up a user by username. -- @query get_user_by_name(name: str) ->? User select id /* :i64 */ , name /* :str */ , email /* :str */ from users where name = : name ; When targeting Rust and the sqlite crate, Squiller would generate roughly*: struct User { id : i64 , name : String , email : String , } /// Look up a user by username. pub fn get_user_by_name ( tx : & mut Transaction , name : & str ) -> Result < Option < User >> { let mut statement = tx . prepare ( r#\" select id, name, email from users where name = :name; \"# ) ? ; statement . bind ( 1 , name ) ? ; match statement . next () ? { State :: Done => Ok ( None ), State :: Row => { let result = User { id : statement . read ( 0 ) ? , name : statement . read ( 1 ) ? , email : statement . read ( 2 ) ? , }; Ok ( Some ( result )) } } } * In reality the generated code is a bit more verbose for several reasons. There are more intermediate variables to make the code easier to generate. There is an additional call to next to avoid leaving statements in progress. And finally, we cache the prepared statement in a hash table, instead of preparing it every call.","title":"Overview"},{"location":"#squiller","text":"Squiller generates boilerplate code from annotated SQL queries. Working with SQL is often tedious, especially in statically typed settings. You need to explicitly bind values to parameters, and extract the resulting values for every column with the right type. Squiller can generate this boilerplate code from a SQL file, based on annotations in comments. Vaporware warning: This is a work in progress. Basic code generation for rust-sqlite works, but the project is pre-alpha quality.","title":"Squiller"},{"location":"#example","text":"Given the following input: -- Look up a user by username. -- @query get_user_by_name(name: str) ->? User select id /* :i64 */ , name /* :str */ , email /* :str */ from users where name = : name ; When targeting Rust and the sqlite crate, Squiller would generate roughly*: struct User { id : i64 , name : String , email : String , } /// Look up a user by username. pub fn get_user_by_name ( tx : & mut Transaction , name : & str ) -> Result < Option < User >> { let mut statement = tx . prepare ( r#\" select id, name, email from users where name = :name; \"# ) ? ; statement . bind ( 1 , name ) ? ; match statement . next () ? { State :: Done => Ok ( None ), State :: Row => { let result = User { id : statement . read ( 0 ) ? , name : statement . read ( 1 ) ? , email : statement . read ( 2 ) ? , }; Ok ( Some ( result )) } } } * In reality the generated code is a bit more verbose for several reasons. There are more intermediate variables to make the code easier to generate. There is an additional call to next to avoid leaving statements in progress. And finally, we cache the prepared statement in a hash table, instead of preparing it every call.","title":"Example"},{"location":"annotating-queries/","text":"Annotating queries \u00b6 The inputs to Squiller are plain SQL files, with annotations in comments. This means that you can run the exact same files through e.g. sqlite or psql , and confirm that the queries are valid. For every annotated query, Squiller generates a corresponding function in the target language that executes that query. If needed, it also generates types for the inputs and outputs of the function. Annotations \u00b6 Squiller ignores all content, until it encounters the marker @query or @begin in a comment. This marks the following query as an annotated query, that it will generate code for. Following the marker is the query signature , which specifies its name, arguments, argument types, and result type, similar to function signatures in other languages. Let\u2019s look at an example: -- Return how many users with the given name exist. -- @query count_users_with_name(name: str) ->1 int select count ( * ) from users where name = : name ; In this example, the signature is @query count_users_with_name ( name : str ) -> 1 int The name of the query is count_users_with_name , and this name will be used for the generated function. The query takes one argument, name , of type str . This will become an argument of the generated function, and that function will bind the provided value to the :name query parameter. After the name and arguments, is an arrow, and then the result type. The arrow includes a cardinality : ->? for a query that returns zero or one rows. ->1 for a query that returns exactly one row. ->* for a query that returns zero or more rows. The exact types that these arrows map to depends on the target, but generally they translate as follows: ->? T maps to Option<T> . ->1 T maps to just T . ->* T maps to Iterator<T> . Query parameters \u00b6 Squiller supports named query parameters with :name syntax. This is one of the syntaxes supported by SQLite , and it allows for named parameters which is less error-prone than position-based parameters. For databases that use a different syntax, such as PostgreSQL , Squiller substitutes the correct syntax in the SQL string literal in the generated code. Documentation comments \u00b6 Squiller preserves any comments immediately preceding the @query marker, up to the first blank line before that marker, as documentation comments . These are included in the output. For example, in Rust they are included as /// -style documentation comments, in Python as docstrings. Tuple result types \u00b6 The result type can be a tuple. In this case, the number of columns that the query returns should match the arity of the tuple. Squiller does not verify this. For example, for the following query it would generate code that fails at runtime, because it tries to access a non-existent third column: -- @query incorrect_result_type() ->1 (str, str, i32) select name , email from users ; Struct result types \u00b6 Because a type such as (str, str, i32) is a bit meaningless, Squiller also supports struct types. Struct types must start with an uppercase ascii letter. The fields of the struct, and their types, are extracted from the query body. This means that type annotations are needed in the body: -- @query get_all_users() ->* User select name /* :str */ , email /* :str */ , karma /* :i32 */ from users ; In this example the fields are name: str , email: str , and karma: i32 . When using struct types, every column that the query selects, should have a type annotation, because Squiller generates code that reads the columns by index. Squiller does not verify that every column is annotated, because it does not do the advanced parsing of the query that would be necessary for this. Every comment between the @query marker and the terminating ; that starts with a : is considered a type annotation, and turns into a struct field. The identifier that immediately precedes the annotation becomes the name of the field, so it can be used with as to control the name: -- @query get_all_users() ->* User select users . name /* :str */ , users . email /* :str */ , sum ( karma_earned ) as karma /* :i32 */ from users , karma_history where users . id = karma_history . user_id group by users . id , users . name , users . email ; As before, this example has fields name: str , email: str , and karma: i32 . Struct arguments \u00b6 Like in result types, structs can be used in arguments. (Unlike tuples, which can only be used in result types.) Struct types can only be used for queries that take a single argument. The name of that argument is preserved in the generated function. As with result types, the fields are extracted from the query body, so all query parameters need a type annotation: -- @query insert_user(user: User) ->1 i64 insert into users ( name , email , karma ) values (: name /* :str */ , : email /* :str */ , : initial_karma /* :i32 */ ) returning id ; Nullable types \u00b6 All primitive types can be made optional or nullable by appending a ? . Primitive types are all types except for structs and tuples, so structs and tuples cannot be made nullable. This is because structs and tuples map to an entire row in SQL , not to individual columns. To specify optionality at the row level, use a ->? result type arrow instead of ->1 . Note, this means that the following two queries would have the same signature in the generated code, even though they have different signatures in SQL : -- @query select_longest_email_length_1() ->1 i64? select max ( length ( email )) from users ; -- @query select_longest_email_length_2() ->? i64 select length ( email ) from users order by length ( email ) desc limit 1 ; Note also that annotating the first query with ->? i64 would result in a runtime error when the users table is empty (because null cannot be decoded into i64 ), and annotating the second query with ->1 i64? would result in a runtime error when the users table is empty as well (because it expects at least one row). Multiple statements \u00b6 You can create functions that execute multiple SQL statements by using a @begin marker to start an annotated query, instead of @query . This can be useful for e.g. migrations. With a @query marker, the query comprises only the statement that follows it, until the terminating semicolon. With a @begin marker, all statements between @begin and @end are included. @end is only valid directly after a semicolon. Let\u2019s look at an example: -- Set up the initial schema. -- @begin init_schema() create table if not exists users ( id integer primary key autoincrement , name text not null , email text not null ); create index ix_users_email on users ( email ); -- @end init_schema In long documents, for clarity it is recommended to repeat the name of the query after the @end marker, but this is not required. When a multi-statement query has a result type, the result type applies to the final statement in the query. Every other statement must not return any rows. Query parameters are allowed in all statements. Note: The @begin and @end markers are unrelated to the SQL statements BEGIN and COMMIT . Squiller never starts transactions implicitly.","title":"Annotating queries"},{"location":"annotating-queries/#annotating-queries","text":"The inputs to Squiller are plain SQL files, with annotations in comments. This means that you can run the exact same files through e.g. sqlite or psql , and confirm that the queries are valid. For every annotated query, Squiller generates a corresponding function in the target language that executes that query. If needed, it also generates types for the inputs and outputs of the function.","title":"Annotating queries"},{"location":"annotating-queries/#annotations","text":"Squiller ignores all content, until it encounters the marker @query or @begin in a comment. This marks the following query as an annotated query, that it will generate code for. Following the marker is the query signature , which specifies its name, arguments, argument types, and result type, similar to function signatures in other languages. Let\u2019s look at an example: -- Return how many users with the given name exist. -- @query count_users_with_name(name: str) ->1 int select count ( * ) from users where name = : name ; In this example, the signature is @query count_users_with_name ( name : str ) -> 1 int The name of the query is count_users_with_name , and this name will be used for the generated function. The query takes one argument, name , of type str . This will become an argument of the generated function, and that function will bind the provided value to the :name query parameter. After the name and arguments, is an arrow, and then the result type. The arrow includes a cardinality : ->? for a query that returns zero or one rows. ->1 for a query that returns exactly one row. ->* for a query that returns zero or more rows. The exact types that these arrows map to depends on the target, but generally they translate as follows: ->? T maps to Option<T> . ->1 T maps to just T . ->* T maps to Iterator<T> .","title":"Annotations"},{"location":"annotating-queries/#query-parameters","text":"Squiller supports named query parameters with :name syntax. This is one of the syntaxes supported by SQLite , and it allows for named parameters which is less error-prone than position-based parameters. For databases that use a different syntax, such as PostgreSQL , Squiller substitutes the correct syntax in the SQL string literal in the generated code.","title":"Query parameters"},{"location":"annotating-queries/#documentation-comments","text":"Squiller preserves any comments immediately preceding the @query marker, up to the first blank line before that marker, as documentation comments . These are included in the output. For example, in Rust they are included as /// -style documentation comments, in Python as docstrings.","title":"Documentation comments"},{"location":"annotating-queries/#tuple-result-types","text":"The result type can be a tuple. In this case, the number of columns that the query returns should match the arity of the tuple. Squiller does not verify this. For example, for the following query it would generate code that fails at runtime, because it tries to access a non-existent third column: -- @query incorrect_result_type() ->1 (str, str, i32) select name , email from users ;","title":"Tuple result types"},{"location":"annotating-queries/#struct-result-types","text":"Because a type such as (str, str, i32) is a bit meaningless, Squiller also supports struct types. Struct types must start with an uppercase ascii letter. The fields of the struct, and their types, are extracted from the query body. This means that type annotations are needed in the body: -- @query get_all_users() ->* User select name /* :str */ , email /* :str */ , karma /* :i32 */ from users ; In this example the fields are name: str , email: str , and karma: i32 . When using struct types, every column that the query selects, should have a type annotation, because Squiller generates code that reads the columns by index. Squiller does not verify that every column is annotated, because it does not do the advanced parsing of the query that would be necessary for this. Every comment between the @query marker and the terminating ; that starts with a : is considered a type annotation, and turns into a struct field. The identifier that immediately precedes the annotation becomes the name of the field, so it can be used with as to control the name: -- @query get_all_users() ->* User select users . name /* :str */ , users . email /* :str */ , sum ( karma_earned ) as karma /* :i32 */ from users , karma_history where users . id = karma_history . user_id group by users . id , users . name , users . email ; As before, this example has fields name: str , email: str , and karma: i32 .","title":"Struct result types"},{"location":"annotating-queries/#struct-arguments","text":"Like in result types, structs can be used in arguments. (Unlike tuples, which can only be used in result types.) Struct types can only be used for queries that take a single argument. The name of that argument is preserved in the generated function. As with result types, the fields are extracted from the query body, so all query parameters need a type annotation: -- @query insert_user(user: User) ->1 i64 insert into users ( name , email , karma ) values (: name /* :str */ , : email /* :str */ , : initial_karma /* :i32 */ ) returning id ;","title":"Struct arguments"},{"location":"annotating-queries/#nullable-types","text":"All primitive types can be made optional or nullable by appending a ? . Primitive types are all types except for structs and tuples, so structs and tuples cannot be made nullable. This is because structs and tuples map to an entire row in SQL , not to individual columns. To specify optionality at the row level, use a ->? result type arrow instead of ->1 . Note, this means that the following two queries would have the same signature in the generated code, even though they have different signatures in SQL : -- @query select_longest_email_length_1() ->1 i64? select max ( length ( email )) from users ; -- @query select_longest_email_length_2() ->? i64 select length ( email ) from users order by length ( email ) desc limit 1 ; Note also that annotating the first query with ->? i64 would result in a runtime error when the users table is empty (because null cannot be decoded into i64 ), and annotating the second query with ->1 i64? would result in a runtime error when the users table is empty as well (because it expects at least one row).","title":"Nullable types"},{"location":"annotating-queries/#multiple-statements","text":"You can create functions that execute multiple SQL statements by using a @begin marker to start an annotated query, instead of @query . This can be useful for e.g. migrations. With a @query marker, the query comprises only the statement that follows it, until the terminating semicolon. With a @begin marker, all statements between @begin and @end are included. @end is only valid directly after a semicolon. Let\u2019s look at an example: -- Set up the initial schema. -- @begin init_schema() create table if not exists users ( id integer primary key autoincrement , name text not null , email text not null ); create index ix_users_email on users ( email ); -- @end init_schema In long documents, for clarity it is recommended to repeat the name of the query after the @end marker, but this is not required. When a multi-statement query has a result type, the result type applies to the final statement in the query. Every other statement must not return any rows. Query parameters are allowed in all statements. Note: The @begin and @end markers are unrelated to the SQL statements BEGIN and COMMIT . Squiller never starts transactions implicitly.","title":"Multiple statements"},{"location":"building/","text":"Building \u00b6 Squiller is written in Rust and builds with Cargo: cargo build --release target/release/squiller Nix \u00b6 The repository comes with a Nix-based development environment that puts pinned versions of the necessary build tools on the PATH. Alternatively, you can source the build tools manually. To enter a development environment with Nix 2.10 , you need to run Nix either with: --extra-experimental-features nix-command --extra-experimental-features flakes or you can add these settings to your ~/.config/nix/nix.conf . Then enter a development shell: nix develop --command $SHELL The Nix flake can also be used to build the application. This is not recommended for development because you lose incremental compilation, but flakes can be a useful way of integrating Squiller into the build pipeline of a different project. To build the flake: nix build result/bin/squiller --help Packaging \u00b6 Squiller can be packaged like any Rust application. A release build with cargo build --release will produce the binary in target/release . The currently supported Rust version is listed in rust-toolchain.toml , but other versions may work. Squiller includes a file src/version.rs with metadata about itself, which gets embedded in generated code for traceability. Please update it before building to include the commit hash of the source checkout. Development \u00b6 Run the unit tests: cargo test Run the golden tests : golden/run.py Run one of the fuzz tests (in this case typecheck ): cargo +nightly-2022-06-25 fuzz run typecheck -- -dict=fuzz/dictionary.txt Build the documentation or view it locally: mkdocs build mkdocs serve","title":"Building"},{"location":"building/#building","text":"Squiller is written in Rust and builds with Cargo: cargo build --release target/release/squiller","title":"Building"},{"location":"building/#nix","text":"The repository comes with a Nix-based development environment that puts pinned versions of the necessary build tools on the PATH. Alternatively, you can source the build tools manually. To enter a development environment with Nix 2.10 , you need to run Nix either with: --extra-experimental-features nix-command --extra-experimental-features flakes or you can add these settings to your ~/.config/nix/nix.conf . Then enter a development shell: nix develop --command $SHELL The Nix flake can also be used to build the application. This is not recommended for development because you lose incremental compilation, but flakes can be a useful way of integrating Squiller into the build pipeline of a different project. To build the flake: nix build result/bin/squiller --help","title":"Nix"},{"location":"building/#packaging","text":"Squiller can be packaged like any Rust application. A release build with cargo build --release will produce the binary in target/release . The currently supported Rust version is listed in rust-toolchain.toml , but other versions may work. Squiller includes a file src/version.rs with metadata about itself, which gets embedded in generated code for traceability. Please update it before building to include the commit hash of the source checkout.","title":"Packaging"},{"location":"building/#development","text":"Run the unit tests: cargo test Run the golden tests : golden/run.py Run one of the fuzz tests (in this case typecheck ): cargo +nightly-2022-06-25 fuzz run typecheck -- -dict=fuzz/dictionary.txt Build the documentation or view it locally: mkdocs build mkdocs serve","title":"Development"},{"location":"changelog/","text":"Changelog \u00b6 0.2.0 \u00b6 Released 2022-10-09. Add support for multi-statement queries, demarcated by @begin and @end . 0.1.0 \u00b6 Released 2022-09-20. Initial release, the application should still be considered beta quality. Rudimentary support for the rust-sqlite target. Some types listed in the documentation are not implemented.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#020","text":"Released 2022-10-09. Add support for multi-statement queries, demarcated by @begin and @end .","title":"0.2.0"},{"location":"changelog/#010","text":"Released 2022-09-20. Initial release, the application should still be considered beta quality. Rudimentary support for the rust-sqlite target. Some types listed in the documentation are not implemented.","title":"0.1.0"},{"location":"datatypes/","text":"Data types \u00b6 Data types in Squiller are inspired by Rust and Python. Strictly speaking they do not map to any SQL types by themselves, only to types in the target language. It is up to the database driver to then map those to SQL types. However, it is still useful to explain the types that Squiller supports in terms of the corresponding SQL data types. Supported types \u00b6 Vaporware warning: Not all of these are implemented. Squiller PostgreSQL SQLite i32 int integer i64 bigint integer f32 float4 number f64 float8 number str text text bytes bytea blob bool bool integer instant timestamptz text 1 1 Encoded to text as an ISO-8601 timestamp with Z suffix. Language mapping \u00b6 Vaporware warning: Not all of these are implemented. Squiller Rust Python Haskell i32 i32 int Int32 i64 i64 int Int64 f32 f32 float Float f64 f64 float Double str &str or String str Text bytes &[u8] or Vec<u8> bytes ByteString bool bool bool Bool instant DateTime<Utc> datetime 1 UtcTime 1 Non-naive datetime, where tzinfo is not None . See also \u00b6 PostgreSQL data type documentation SQLite data type documentation","title":"Data types"},{"location":"datatypes/#data-types","text":"Data types in Squiller are inspired by Rust and Python. Strictly speaking they do not map to any SQL types by themselves, only to types in the target language. It is up to the database driver to then map those to SQL types. However, it is still useful to explain the types that Squiller supports in terms of the corresponding SQL data types.","title":"Data types"},{"location":"datatypes/#supported-types","text":"Vaporware warning: Not all of these are implemented. Squiller PostgreSQL SQLite i32 int integer i64 bigint integer f32 float4 number f64 float8 number str text text bytes bytea blob bool bool integer instant timestamptz text 1 1 Encoded to text as an ISO-8601 timestamp with Z suffix.","title":"Supported types"},{"location":"datatypes/#language-mapping","text":"Vaporware warning: Not all of these are implemented. Squiller Rust Python Haskell i32 i32 int Int32 i64 i64 int Int64 f32 f32 float Float f64 f64 float Double str &str or String str Text bytes &[u8] or Vec<u8> bytes ByteString bool bool bool Bool instant DateTime<Utc> datetime 1 UtcTime 1 Non-naive datetime, where tzinfo is not None .","title":"Language mapping"},{"location":"datatypes/#see-also","text":"PostgreSQL data type documentation SQLite data type documentation","title":"See also"},{"location":"golden-tests/","text":"Golden tests \u00b6 Squiller has a suite of golden tests: inputs with known-good outputs. At the time of writing they are used to test error reporting for incorrect inputs, but they should be extended to testing generated code. Golden tests are a good fit for testing the parser and error reporting, because textual input is easier to construct than manually constructing an AST in a unit test. Golden tests are located in the golden directory, and can be executed with golden/run.py . See also run.py --help for usage. Test cases are files with a .test extension. The file consists of the test input, which is fed to sqiller on stdin, then two blank lines, and then the expected output. When the actual output does not match the expected output, run.py prints a diff.","title":"Golden tests"},{"location":"golden-tests/#golden-tests","text":"Squiller has a suite of golden tests: inputs with known-good outputs. At the time of writing they are used to test error reporting for incorrect inputs, but they should be extended to testing generated code. Golden tests are a good fit for testing the parser and error reporting, because textual input is easier to construct than manually constructing an AST in a unit test. Golden tests are located in the golden directory, and can be executed with golden/run.py . See also run.py --help for usage. Test cases are files with a .test extension. The file consists of the test input, which is fed to sqiller on stdin, then two blank lines, and then the expected output. When the actual output does not match the expected output, run.py prints a diff.","title":"Golden tests"},{"location":"targets/","text":"Targets \u00b6 Squiller can generate code for the following targets. python-psycopg2 \u00b6 Vaporware warning: Development of this target is in progress. Target Python and Postgres through the Psycopg2 package. Generated code includes type annotations. This target is tested against the following versions, although other versions may work: Python 3.9.10 Psycopg2 2.9.3 rust-sqlite \u00b6 Target Rust and SQLite through the sqlite crate. This target is tested against the following versions, although other versions may work: Rust 1.57.0, 2018 edition Sqlite crate 0.26.0","title":"Targets"},{"location":"targets/#targets","text":"Squiller can generate code for the following targets.","title":"Targets"},{"location":"targets/#python-psycopg2","text":"Vaporware warning: Development of this target is in progress. Target Python and Postgres through the Psycopg2 package. Generated code includes type annotations. This target is tested against the following versions, although other versions may work: Python 3.9.10 Psycopg2 2.9.3","title":"python-psycopg2"},{"location":"targets/#rust-sqlite","text":"Target Rust and SQLite through the sqlite crate. This target is tested against the following versions, although other versions may work: Rust 1.57.0, 2018 edition Sqlite crate 0.26.0","title":"rust-sqlite"},{"location":"usage/","text":"Squiller \u00b6 Generate boilerplate code from annotated SQL queries. Synopsis \u00b6 squiller --target <target> <file>... squiller --target help squiller --help Description \u00b6 Squiller parses all of the given inputs files, generates code from them for the specified target, and writes that to stdout. <file>... can be one or more UTF-8 text files that contain SQL , or - to read from stdin. Options \u00b6 --target \u00b6 Specifies the target language and database driver to generate code for. Targets follow the <language>-<driver> naming scheme, all lowercase. The special value help lists all supported targets. In that case, no input files need to be specified. --help \u00b6 Print usage information. --version \u00b6 Print version information.","title":"Usage"},{"location":"usage/#squiller","text":"Generate boilerplate code from annotated SQL queries.","title":"Squiller"},{"location":"usage/#synopsis","text":"squiller --target <target> <file>... squiller --target help squiller --help","title":"Synopsis"},{"location":"usage/#description","text":"Squiller parses all of the given inputs files, generates code from them for the specified target, and writes that to stdout. <file>... can be one or more UTF-8 text files that contain SQL , or - to read from stdin.","title":"Description"},{"location":"usage/#options","text":"","title":"Options"},{"location":"usage/#-target","text":"Specifies the target language and database driver to generate code for. Targets follow the <language>-<driver> naming scheme, all lowercase. The special value help lists all supported targets. In that case, no input files need to be specified.","title":"--target"},{"location":"usage/#-help","text":"Print usage information.","title":"--help"},{"location":"usage/#-version","text":"Print version information.","title":"--version"},{"location":"theme/","text":"Kilsbergen \u00b6 A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more. Demos \u00b6 Musium documentation Noblit documentation Pris documentation Squiller documentation Tako documentation Features \u00b6 Responsive design Zero javascript Usage \u00b6 One easy way to use this theme, is to add it as a Git submodule to your docs directory, e.g. at docs/theme . Then add the following in your mkdocs.yml : theme : name : null custom_dir : docs/theme This theme requires MkDocs 1.1 or later. For earlier versions, delete this README.md to work around this bug . To enable anchors next to section headings, add the following to your mkdocs.yml : markdown_extensions : - toc : permalink : true permalink_title : null To enable syntax highlighting, ensure that pygmentize is available, and add the following to your mkdocs.yml : markdown_extensions : - codehilite See also the python-markdown list of extensions . License \u00b6 Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"Kilsbergen"},{"location":"theme/#kilsbergen","text":"A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more.","title":"Kilsbergen"},{"location":"theme/#demos","text":"Musium documentation Noblit documentation Pris documentation Squiller documentation Tako documentation","title":"Demos"},{"location":"theme/#features","text":"Responsive design Zero javascript","title":"Features"},{"location":"theme/#usage","text":"One easy way to use this theme, is to add it as a Git submodule to your docs directory, e.g. at docs/theme . Then add the following in your mkdocs.yml : theme : name : null custom_dir : docs/theme This theme requires MkDocs 1.1 or later. For earlier versions, delete this README.md to work around this bug . To enable anchors next to section headings, add the following to your mkdocs.yml : markdown_extensions : - toc : permalink : true permalink_title : null To enable syntax highlighting, ensure that pygmentize is available, and add the following to your mkdocs.yml : markdown_extensions : - codehilite See also the python-markdown list of extensions .","title":"Usage"},{"location":"theme/#license","text":"Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"License"}]}