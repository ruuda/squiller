{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Querybinder Querybinder generates boilerplate code from annotated SQL queries. Working with SQL is often tedious, especially in statically typed settings. You need to explicitly bind values to parameters, and extract the resulting values for every column with the right type. Querybinder can generate this boilerplate code from a SQL file, based on annotations in comments. Vaporware warning: This is a work in progress. Basic code generation for rust-sqlite works, but the project is pre-alpha quality. Example Given the following input: -- Look up a user by username. -- @query get_user_by_name(name: str) ->? User select id /* :i64 */, name /* :str */, email /* :str */ from users where name = :name; When targeting Rust and the sqlite crate, Querybinder would generate roughly*: struct User { id: i64, name: String, email: String, } /// Look up a user by username. pub fn get_user_by_name( tx: &mut Transaction, name: &str ) -> Result<Option<User>> { let mut statement = tx.prepare( r#\" select id, name, email from users where name = :name; \"# )?; statement.bind(1, name)?; match statement.next()? { State::Done => Ok(None), State::Row => { let result = User { id: statement.read(0)?, name: statement.read(1)?, email: statement.read(2)?, }; Ok(Some(result)) } } } * In reality the generated code is a bit more verbose, on the one hand to make it easier to generate, and on the other hand to cache the prepared statement in a hash table, instead of preparing it every call.","title":"Overview"},{"location":"#querybinder","text":"Querybinder generates boilerplate code from annotated SQL queries. Working with SQL is often tedious, especially in statically typed settings. You need to explicitly bind values to parameters, and extract the resulting values for every column with the right type. Querybinder can generate this boilerplate code from a SQL file, based on annotations in comments. Vaporware warning: This is a work in progress. Basic code generation for rust-sqlite works, but the project is pre-alpha quality.","title":"Querybinder"},{"location":"#example","text":"Given the following input: -- Look up a user by username. -- @query get_user_by_name(name: str) ->? User select id /* :i64 */, name /* :str */, email /* :str */ from users where name = :name; When targeting Rust and the sqlite crate, Querybinder would generate roughly*: struct User { id: i64, name: String, email: String, } /// Look up a user by username. pub fn get_user_by_name( tx: &mut Transaction, name: &str ) -> Result<Option<User>> { let mut statement = tx.prepare( r#\" select id, name, email from users where name = :name; \"# )?; statement.bind(1, name)?; match statement.next()? { State::Done => Ok(None), State::Row => { let result = User { id: statement.read(0)?, name: statement.read(1)?, email: statement.read(2)?, }; Ok(Some(result)) } } } * In reality the generated code is a bit more verbose, on the one hand to make it easier to generate, and on the other hand to cache the prepared statement in a hash table, instead of preparing it every call.","title":"Example"},{"location":"annotating-queries/","text":"Annotating queries The inputs to Querybinder are plain SQL files, with annotations in comments. This means that you can run the exact same files through e.g. sqlite or psql , and confirm that the queries are valid. For every annotated query, Querybinder generates a corresponding function in the target language that executes that query. If needed, it also generates types for the inputs and outputs of the function. Annotations Querybinder ignores all content, until it encounters the marker @query in a comment. This marks the following query as an annotated query, that it will generate code for. Following the @query is the query signature , which specifies its name, arguments, argument types, and result type, similar to function signatures in other languages. Let\u2019s look at an example: -- Return how many users with the given name exist. -- @query count_users_with_name(name: str) ->? int select count(*) from users where name = :name; In this example, the signature is @query count_users_with_name(name: str) ->? int The name of the query is count_users_with_name , and this name will be used for the generated function. The query takes one argument, name , of type str . This will become an argument of the generated function, and that function will bind the provided value to the :name query parameter. After the name and arguments, is an arrow, and then the result type. The arrow includes a cardinality : ->? for a query that returns zero or one rows. ->1 for a query that returns exactly one row. ->* for a query that returns zero or more rows. The exact types that these arrows map to depends on the target, but generally they translate as follows: ->? T maps to Option<T> . ->1 T maps to just T . ->* T maps to Iterator<T> . Query parameters Querybinder supports named query parameters with :name syntax. This is one of the syntaxes supported by SQLite , and it allows for named parameters which is less error-prone than position-based parameters. For databases that use a different syntax, such as PostgreSQL , Querybinder substitutes the correct syntax in the SQL string literal in the generated code. Documentation comments Querybinder preserves any comments immediately preceding the @query marker, up to the first blank line before that marker, as documentation comments . These are included in the output. For example, in Rust they are included as /// -style documentation comments, in Python as docstrings. Tuple result types The result type can be a tuple. In this case, the number of columns that the query returns should match the arity of the tuple. Querybinder does not verify this. For example, for the following query it would generate code that fails at runtime, because it tries to access a non-existent third column: -- @query incorrect_result_type() ->1 (str, str, i32) select name, email from users; Struct result types Because a type such as (str, str, i32) is a bit meaningless, Querybinder also supports struct types. Struct types must start with an uppercase ascii letter. The fields of the struct, and their types, are extracted from the query body. This means that type annotations are needed in the body: -- @query get_all_users() ->* User select name /* :str */, email /* :str */, karma /* :i32 */ from users; In this example the fields are name: str , email: str , and karma: i32 . When using struct types, every column that the query selects, should have a type annotation, because Querybinder generates code that reads the columns by index. Querybinder does not verify that every column is annotated, because it does not do the advanced parsing of the query that would be necessary for this. Every comment between the @query marker and the terminating ; that starts with a : is considered a type annotation, and turns into a struct field. The identifier that immediately precedes the annotation becomes the name of the field, so it can be used with as to control the name: -- @query get_all_users() ->* User select users.name /* :str */, users.email /* :str */, sum(karma_earned) as karma /* :i32 */ from users, karma_history where users.id = karma_history.user_id group by users.id, users.name, users.email; As before, this example has fields name: str , email: str , and karma: i32 . Struct arguments Like in result types, structs can be used in arguments. (Unlike tuples, which can only be used in result types.) Struct types can only be used for queries that take a single argument. The name of that argument is preserved in the generated function. As with result types, the fields are extracted from the query body, so all query parameters need a type annotation: -- @query insert_user(user: User) ->1 i64 insert into users (name, email, karma) values (:name /* :str */, :email /* :str */, :initial_karma /* :i32 */) returning id; Nullable types All primitive types can be made optional or nullable by appending a ? . Primitive types are all types except for structs and tuples, so structs and tuples cannot be made nullable. This is because structs and tuples map to an entire row in SQL , not to individual columns. To specify optionality at the row level, use a ->? result type arrow instead of ->1 . Note, this means that the following two queries would have the same signature in the generated code, even though they have different signatures in SQL : -- @query select_longest_email_length_1() ->1 i64? select max(length(email)) from users; -- @query select_longest_email_length_2() ->? i64 select length(email) from users order by length(email) desc limit 1; Note also that annotating the first query with ->? i64 would result in a runtime error when the users table is empty (because null cannot be decoded into i64 ), and annotating the second query with ->1 i64? would result in a runtime error when the users table is empty as well (because it expects at least one row).","title":"Annotating queries"},{"location":"annotating-queries/#annotating-queries","text":"The inputs to Querybinder are plain SQL files, with annotations in comments. This means that you can run the exact same files through e.g. sqlite or psql , and confirm that the queries are valid. For every annotated query, Querybinder generates a corresponding function in the target language that executes that query. If needed, it also generates types for the inputs and outputs of the function.","title":"Annotating queries"},{"location":"annotating-queries/#annotations","text":"Querybinder ignores all content, until it encounters the marker @query in a comment. This marks the following query as an annotated query, that it will generate code for. Following the @query is the query signature , which specifies its name, arguments, argument types, and result type, similar to function signatures in other languages. Let\u2019s look at an example: -- Return how many users with the given name exist. -- @query count_users_with_name(name: str) ->? int select count(*) from users where name = :name; In this example, the signature is @query count_users_with_name(name: str) ->? int The name of the query is count_users_with_name , and this name will be used for the generated function. The query takes one argument, name , of type str . This will become an argument of the generated function, and that function will bind the provided value to the :name query parameter. After the name and arguments, is an arrow, and then the result type. The arrow includes a cardinality : ->? for a query that returns zero or one rows. ->1 for a query that returns exactly one row. ->* for a query that returns zero or more rows. The exact types that these arrows map to depends on the target, but generally they translate as follows: ->? T maps to Option<T> . ->1 T maps to just T . ->* T maps to Iterator<T> .","title":"Annotations"},{"location":"annotating-queries/#query-parameters","text":"Querybinder supports named query parameters with :name syntax. This is one of the syntaxes supported by SQLite , and it allows for named parameters which is less error-prone than position-based parameters. For databases that use a different syntax, such as PostgreSQL , Querybinder substitutes the correct syntax in the SQL string literal in the generated code.","title":"Query parameters"},{"location":"annotating-queries/#documentation-comments","text":"Querybinder preserves any comments immediately preceding the @query marker, up to the first blank line before that marker, as documentation comments . These are included in the output. For example, in Rust they are included as /// -style documentation comments, in Python as docstrings.","title":"Documentation comments"},{"location":"annotating-queries/#tuple-result-types","text":"The result type can be a tuple. In this case, the number of columns that the query returns should match the arity of the tuple. Querybinder does not verify this. For example, for the following query it would generate code that fails at runtime, because it tries to access a non-existent third column: -- @query incorrect_result_type() ->1 (str, str, i32) select name, email from users;","title":"Tuple result types"},{"location":"annotating-queries/#struct-result-types","text":"Because a type such as (str, str, i32) is a bit meaningless, Querybinder also supports struct types. Struct types must start with an uppercase ascii letter. The fields of the struct, and their types, are extracted from the query body. This means that type annotations are needed in the body: -- @query get_all_users() ->* User select name /* :str */, email /* :str */, karma /* :i32 */ from users; In this example the fields are name: str , email: str , and karma: i32 . When using struct types, every column that the query selects, should have a type annotation, because Querybinder generates code that reads the columns by index. Querybinder does not verify that every column is annotated, because it does not do the advanced parsing of the query that would be necessary for this. Every comment between the @query marker and the terminating ; that starts with a : is considered a type annotation, and turns into a struct field. The identifier that immediately precedes the annotation becomes the name of the field, so it can be used with as to control the name: -- @query get_all_users() ->* User select users.name /* :str */, users.email /* :str */, sum(karma_earned) as karma /* :i32 */ from users, karma_history where users.id = karma_history.user_id group by users.id, users.name, users.email; As before, this example has fields name: str , email: str , and karma: i32 .","title":"Struct result types"},{"location":"annotating-queries/#struct-arguments","text":"Like in result types, structs can be used in arguments. (Unlike tuples, which can only be used in result types.) Struct types can only be used for queries that take a single argument. The name of that argument is preserved in the generated function. As with result types, the fields are extracted from the query body, so all query parameters need a type annotation: -- @query insert_user(user: User) ->1 i64 insert into users (name, email, karma) values (:name /* :str */, :email /* :str */, :initial_karma /* :i32 */) returning id;","title":"Struct arguments"},{"location":"annotating-queries/#nullable-types","text":"All primitive types can be made optional or nullable by appending a ? . Primitive types are all types except for structs and tuples, so structs and tuples cannot be made nullable. This is because structs and tuples map to an entire row in SQL , not to individual columns. To specify optionality at the row level, use a ->? result type arrow instead of ->1 . Note, this means that the following two queries would have the same signature in the generated code, even though they have different signatures in SQL : -- @query select_longest_email_length_1() ->1 i64? select max(length(email)) from users; -- @query select_longest_email_length_2() ->? i64 select length(email) from users order by length(email) desc limit 1; Note also that annotating the first query with ->? i64 would result in a runtime error when the users table is empty (because null cannot be decoded into i64 ), and annotating the second query with ->1 i64? would result in a runtime error when the users table is empty as well (because it expects at least one row).","title":"Nullable types"},{"location":"building/","text":"Building Querybinder is written in Rust and builds with Cargo: cargo build --release target/release/querybinder Nix The repository comes with a Nix-based development environment that puts pinned versions of the necessary build tools on the PATH. Alternatively, you can source the build tools manually. To enter a development environment with Nix 2.10 , you need to run Nix either with: --extra-experimental-features nix-command --extra-experimental-features flakes or you can add these settings to your ~/.config/nix/nix.conf . Then enter a development shell: nix develop --command $SHELL The Nix flake can also be used to build the application. This is not recommended for development because you lose incremental compilation, but flakes can be a useful way of integrating Querybinder into the build pipeline of a different project. To build the flake: nix build result/bin/querybinder --help Development Run the unit tests: cargo test Run the golden tests : golden/run.py Run one of the fuzz tests (in this case typecheck ): cargo +nightly-2022-06-25 fuzz run typecheck -- -dict=fuzz/dictionary.txt Build the documentation or view it locally: mkdocs build mkdocs serve","title":"Building"},{"location":"building/#building","text":"Querybinder is written in Rust and builds with Cargo: cargo build --release target/release/querybinder","title":"Building"},{"location":"building/#nix","text":"The repository comes with a Nix-based development environment that puts pinned versions of the necessary build tools on the PATH. Alternatively, you can source the build tools manually. To enter a development environment with Nix 2.10 , you need to run Nix either with: --extra-experimental-features nix-command --extra-experimental-features flakes or you can add these settings to your ~/.config/nix/nix.conf . Then enter a development shell: nix develop --command $SHELL The Nix flake can also be used to build the application. This is not recommended for development because you lose incremental compilation, but flakes can be a useful way of integrating Querybinder into the build pipeline of a different project. To build the flake: nix build result/bin/querybinder --help","title":"Nix"},{"location":"building/#development","text":"Run the unit tests: cargo test Run the golden tests : golden/run.py Run one of the fuzz tests (in this case typecheck ): cargo +nightly-2022-06-25 fuzz run typecheck -- -dict=fuzz/dictionary.txt Build the documentation or view it locally: mkdocs build mkdocs serve","title":"Development"},{"location":"datatypes/","text":"Data types Data types in Querybinder are inspired by Rust and Python. Strictly speaking they do not map to any SQL types by themselves, only to types in the target language. It is up to the database driver to then map those to SQL types. However, it is still useful to explain the types that Querybinder supports in terms of the corresponding SQL data types. Supported types Vaporware warning: Not all of these are implemented. Querybinder PostgreSQL SQLite i32 int integer i64 bigint integer str text text bytes bytea blob bool bool integer instant timestamptz text 1 1 Encoded to text as an ISO-8601 timestamp with Z suffix. Language mapping Vaporware warning: Not all of these are implemented. Querybinder Rust Python Haskell i32 i32 int Int32 i64 i64 int Int64 str &str or String str Text bytes &[u8] or Vec<u8> bytes ByteString bool bool bool Bool instant DateTime<Utc> datetime 1 UtcTime 1 Non-naive datetime, where tzinfo is not None . See also PostgreSQL data type documentation SQLite data type documentation","title":"Data types"},{"location":"datatypes/#data-types","text":"Data types in Querybinder are inspired by Rust and Python. Strictly speaking they do not map to any SQL types by themselves, only to types in the target language. It is up to the database driver to then map those to SQL types. However, it is still useful to explain the types that Querybinder supports in terms of the corresponding SQL data types.","title":"Data types"},{"location":"datatypes/#supported-types","text":"Vaporware warning: Not all of these are implemented. Querybinder PostgreSQL SQLite i32 int integer i64 bigint integer str text text bytes bytea blob bool bool integer instant timestamptz text 1 1 Encoded to text as an ISO-8601 timestamp with Z suffix.","title":"Supported types"},{"location":"datatypes/#language-mapping","text":"Vaporware warning: Not all of these are implemented. Querybinder Rust Python Haskell i32 i32 int Int32 i64 i64 int Int64 str &str or String str Text bytes &[u8] or Vec<u8> bytes ByteString bool bool bool Bool instant DateTime<Utc> datetime 1 UtcTime 1 Non-naive datetime, where tzinfo is not None .","title":"Language mapping"},{"location":"datatypes/#see-also","text":"PostgreSQL data type documentation SQLite data type documentation","title":"See also"},{"location":"golden-tests/","text":"Golden tests Querybinder has a suite of golden tests: inputs with known-good outputs. At the time of writing they are used to test error reporting for incorrect inputs, but they should be extended to testing generated code. Golden tests are a good fit for testing the parser and error reporting, because textual input is easier to construct than manually constructing an AST in a unit test. Golden tests are located in the golden directory, and can be executed with golden/run.py . See also run.py --help for usage. Test cases are files with a .test extension. The file consists of the test input, which is fed to querybinder on stdin, then two blank lines, and then the expected output. When the actual output does not match the expected output, run.py prints a diff.","title":"Golden tests"},{"location":"golden-tests/#golden-tests","text":"Querybinder has a suite of golden tests: inputs with known-good outputs. At the time of writing they are used to test error reporting for incorrect inputs, but they should be extended to testing generated code. Golden tests are a good fit for testing the parser and error reporting, because textual input is easier to construct than manually constructing an AST in a unit test. Golden tests are located in the golden directory, and can be executed with golden/run.py . See also run.py --help for usage. Test cases are files with a .test extension. The file consists of the test input, which is fed to querybinder on stdin, then two blank lines, and then the expected output. When the actual output does not match the expected output, run.py prints a diff.","title":"Golden tests"},{"location":"usage/","text":"Querybinder Generate boilerplate code from annotated SQL queries. Synopsis querybinder --target <target> <file>... querybinder --target help querybinder --help Description Querybinder parses all of the given inputs files, generates code from them for the specified target, and writes that to stdout. <file>... can be one or more UTF-8 text files that contain SQL , or - to read from stdin. Options --target Specifies the target language and database driver to generate code for. Targets follow the <language>-<driver> naming scheme, all lowercase. The special value help lists all supported targets. In that case, no input files need to be specified. --help Print usage information. --version Print version information.","title":"Usage"},{"location":"usage/#querybinder","text":"Generate boilerplate code from annotated SQL queries.","title":"Querybinder"},{"location":"usage/#synopsis","text":"querybinder --target <target> <file>... querybinder --target help querybinder --help","title":"Synopsis"},{"location":"usage/#description","text":"Querybinder parses all of the given inputs files, generates code from them for the specified target, and writes that to stdout. <file>... can be one or more UTF-8 text files that contain SQL , or - to read from stdin.","title":"Description"},{"location":"usage/#options","text":"","title":"Options"},{"location":"usage/#-target","text":"Specifies the target language and database driver to generate code for. Targets follow the <language>-<driver> naming scheme, all lowercase. The special value help lists all supported targets. In that case, no input files need to be specified.","title":"--target"},{"location":"usage/#-help","text":"Print usage information.","title":"--help"},{"location":"usage/#-version","text":"Print version information.","title":"--version"},{"location":"theme/","text":"Kilsbergen A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more. Demos Musium documentation Noblit documentation Pris documentation Tako documentation Features Responsive design Zero javascript Usage One easy way to use this theme, is to add it as a Git submodule to your docs directory, e.g. at docs/theme . Then add the following in your mkdocs.yml : theme: name: null custom_dir: docs/theme This theme requires MkDocs 1.1 or later. For earlier versions, delete this README.md to work around this bug . License Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"Kilsbergen"},{"location":"theme/#kilsbergen","text":"A clean MkDocs theme. This theme is designed for Tako , Pris , and Noblit . It is not flexible on purpose: it supports everything I need, and nothing more.","title":"Kilsbergen"},{"location":"theme/#demos","text":"Musium documentation Noblit documentation Pris documentation Tako documentation","title":"Demos"},{"location":"theme/#features","text":"Responsive design Zero javascript","title":"Features"},{"location":"theme/#usage","text":"One easy way to use this theme, is to add it as a Git submodule to your docs directory, e.g. at docs/theme . Then add the following in your mkdocs.yml : theme: name: null custom_dir: docs/theme This theme requires MkDocs 1.1 or later. For earlier versions, delete this README.md to work around this bug .","title":"Usage"},{"location":"theme/#license","text":"Kilsbergen is licensed under the Apache 2.0 license. In the generated documentation, it is fine to just link to this readme from a comment.","title":"License"}]}