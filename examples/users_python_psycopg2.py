# This file was generated by Squiller 0.5.0-dev (unspecified checkout).
# Input files:
# - examples/users.sql

from __future__ import annotations

import contextlib

from typing import Any, Iterator, NamedTuple, Optional

import psycopg2.extensions  # type: ignore
import psycopg2.extras  # type: ignore
import psycopg2.pool  # type: ignore


class Transaction:
    def __init__(self, conn: psycopg2.extensions.connection) -> None:
        self.conn = conn

    def commit(self) -> None:
        self.conn.commit()
        # Ensure we cannot reuse the connection.
        self.conn = None

    def rollback(self) -> None:
        self.conn.rollback()
        self.conn = None

    def cursor(self) -> psycopg2.extensions.cursor:
        return self.conn.cursor()


class ConnectionPool(NamedTuple):
    pool: psycopg2.pool.ThreadedConnectionPool

    @contextlib.contextmanager
    def begin(self) -> Iterator[Transaction]:
        conn: Optional[psycopg2.extensions.connection] = None
        try:
            # Use psycopg2 in "no-autocommit" mode, where it implicitly starts a
            # transaction at the first statement, and we need to explicitly
            # commit() or rollback() afterwards.
            conn = self.pool.getconn()
            conn.isolation_level = "SERIALIZABLE"
            conn.autocommit = False
            yield Transaction(conn)

        except:
            if conn is not None:
                self.pool.putconn(conn, close=True)
            raise

        else:
            assert conn is not None
            self.pool.putconn(conn, close=False)


def setup_schema(tx: Transaction) -> None:
    sql = """
        create table if not exists users
          ( id    integer primary key
          , name  string not null
          , email string not null
          );
        """
    params = ()
    return None


def insert_user(tx: Transaction, name, email) -> Any:
    """
    Insert a new user and return its id.
    """
    sql = """
        insert into
          users (name, email)
        values
          (%s, %s)
        returning
          id;
        """
    params = (
        name,
        email,
    )
    return None


def insert_user_alt_return(tx: Transaction, name, email) -> Any:
    """
    TODO: Add global type detection, use a single "User" type everywhere.
    Insert a new user and return it.
    """
    sql = """
        insert into
          users (name, email)
        values
          (%s, %s)
        returning
          id,
          name,
          email;
        """
    params = (
        name,
        email,
    )
    return None


def insert_user_alt_arg(tx: Transaction, user: InsertUser) -> Any:
    """
    Insert a new user and return its id.
    """
    sql = """
        insert into
          users (name, email)
        values
          (%s, %s)
        returning
          id;
        """
    params = (
        name,
        email,
    )
    return None


def select_user_by_id(tx: Transaction, id) -> Any:
    """
    Select a particular user by id.

    We make a choice here to always expect one row, with "->1". If a user with
    the given id does not exist, the function will panic. Alternatively, we could
    write "->?", and then the return type would be wrapped in option in the
    generated code, allowing us to handle the error.
    """
    sql = """
        select
          id,
          name,
          email
        from
          users
        where
          id = %s;
        """
    params = (id,)
    return None


def select_all_users(tx: Transaction) -> Iterator[Any]:
    """
    Iterate over all users ordered by id.
    """
    sql = """
        select
          id,
          name,
          email
        from
          users
        order by
          id asc;
        """
    params = ()
    return None


def select_longest_email_length(tx: Transaction) -> Any:
    """
    Select the length of the longest email address.
    Note, `max` returns null when the table is empty, hence the `?` on the `i64`.
    """
    sql = """
        select
          max(length(email))
        from
          users;
        """
    params = ()
    return None


def select_longest_email_length_alt(tx: Transaction) -> Optional[Any]:
    """
    Select the length of the longest email address.
    This query returns the same result as [`select_longest_email_length`], and
    will have the same type in the generated code, but it works differently under
    the hood: it returns zero or one rows with a non-null column, as opposed to
    returning exactly one row with a nullable column.
    """
    sql = """
        select
          length(email)
        from
          users
        order by
          length(email) desc
        limit
          1;
        """
    params = ()
    return None
